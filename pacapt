#!/usr/bin/env sh
#
# Purpose: A wrapper for all Unix package managers
# License: Fair license (http://www.opensource.org/licenses/fair)
# Source : http://github.com/icy/pacapt/
# Version: 3.0.0
# Authors: Anh K. Huynh et al.

# Copyright (C) 2010 - 2021 \
#                           | 10sr (10sr)
#                           | Alexander Dupuy (dupuy)
#                           | Anh K. Huynh (icy)
#                           | Antony Lee (anntzer)
#                           | Alex Lyon (Arcterus)
#                           | Carl X. Su (bcbcarl)
#                           | Cuong Manh Le (Gnouc)
#                           | Daniel YC Lin (dlintw)
#                           | Danny George (dangets)
#                           | Darshit Shah (darnir)
#                           | Dmitry Kudriavtsev (dkudriavtsev)
#                           | Eric Crosson (EricCrosson)
#                           | Evan Relf (evanrelf)
#                           | GijsTimmers (GijsTimmers)
#                           | Hà-Dương Nguyễn (cmpitg)
#                           | Huy Ngô (NgoHuy)
#                           | James Pearson (xiongchiamiov)
#                           | Janne Heß (dasJ)
#                           | Jiawei Zhou (4679)
#                           | Karol Blazewicz
#                           | Kevin Brubeck (unhammer)
#                           | Konrad Borowski (xfix)
#                           | Kylie McClain (somasis)
#                           | Gen Li (Rami3L)
#                           | Valerio Pizzi (Pival81)
#                           | Siôn Le Roux (sinisterstuf)
#                           | Thiago Perrotta (thiagowfx)
#                           | Vojtech Letal (letalvoj)
#
# Usage of the works is permitted provided that this instrument is
# retained with the works, so that any entity that uses the works is
# notified of this instrument.
#
# DISCLAIMER: THE WORKS ARE WITHOUT WARRANTY.
#

_print_pacapt_version() {
  cat <<_EOF_
pacapt version '3.0.0'

Copyright (C) 2010 - 2021 \\
                          | 10sr (10sr)
                          | Alexander Dupuy (dupuy)
                          | Anh K. Huynh (icy)
                          | Antony Lee (anntzer)
                          | Alex Lyon (Arcterus)
                          | Carl X. Su (bcbcarl)
                          | Cuong Manh Le (Gnouc)
                          | Daniel YC Lin (dlintw)
                          | Danny George (dangets)
                          | Darshit Shah (darnir)
                          | Dmitry Kudriavtsev (dkudriavtsev)
                          | Eric Crosson (EricCrosson)
                          | Evan Relf (evanrelf)
                          | GijsTimmers (GijsTimmers)
                          | Hà-Dương Nguyễn (cmpitg)
                          | Huy Ngô (NgoHuy)
                          | James Pearson (xiongchiamiov)
                          | Janne Heß (dasJ)
                          | Jiawei Zhou (4679)
                          | Karol Blazewicz
                          | Kevin Brubeck (unhammer)
                          | Konrad Borowski (xfix)
                          | Kylie McClain (somasis)
                          | Gen Li (Rami3L)
                          | Valerio Pizzi (Pival81)
                          | Siôn Le Roux (sinisterstuf)
                          | Thiago Perrotta (thiagowfx)
                          | Vojtech Letal (letalvoj)

Usage of the works is permitted provided that this
instrument is retained with the works, so that any
entity that uses the works is notified of this instrument.

DISCLAIMER: THE WORKS ARE WITHOUT WARRANTY.
_EOF_
}

export PACAPT_VERSION='3.0.0'

_help() {
  cat <<'EOF'
NAME
  pacapt - An `ArchLinux`'s pacman-like wrapper for many package managers.

SYNTAX

  $ pacapt <option(s)> <operation(s)> <package(s)>

BASIC OPTIONS

    -h or --help    print this help message
    -P              print supported operations
    -V              print version information

SYSGET STYLE OPERATIONS

  update                        Update package database
  upgrade                       Upgrade system
  install <options> <packages>  Install some packages
  search  <options> <package>   Search some package
  remove  <options> <packages>  Remove some packages
  autoremove                    Remove orphans (WIP; may not work correctly)
  clean                         Clean package manager caches

PACMAN STYLE OPERATIONS

  Query
    -Q              list all installed packages
    -Qc <package>   show package's changelog
    -Qe [<package>] only list explicitly installed packages
    -Qi <package>   print package status
    -Ql <package>   list package's files
    -Qm             list installed packages that aren't available
                    in any installation source
    -Qo <file>      query package that provides <file>
    -Qp <file>      query a package file (don't use package database)
    -Qs <package>   search for installed package

  Synchronize
    -S <package>    install package(s)
    -Sg             list groups
    -Sg <group>     list packages in group
    -Ss <package>   search for packages
    -Su             upgrade the system
    -Sy             update package database
    -Suy            update package database, then upgrade the system

  Remove / Clean up
    -R <packages>   remove some packages
    -Sc             delete old downloaded packages
    -Scc            delete all downloaded packages
    -Sccc           clean variant files.
                    (debian) See also http://dragula.viettug.org/blogs/646

  Upgrade
    -U              upgrade or add package from local file path (or remote uri)

OPTIONS

    -w              download packages but don't install them
    --noconfirm     don't wait for user's confirmation

EXAMPLES

  1. To install a package from Debian's backports repository
      $ pacapt -S foobar -t lenny-backports
      $ pacapt -S -- -t lenny-backports foobar

  2. To update package database and then update your system
      $ pacapt -Syu

  3. To download a package without installing it
      $ pacapt -Sw foobar


ENVIRONMENT

  PACAPT_DEBUG

    This is useful for debugging purpose. The variable can be set to `auto`
    or any valid packager. For example, on `Debian` system the two following
    commands are the same and they will print out what the script would do:

        PACAPT_DEBUG=auto pacman -Su
        PACAPT_DEBUG=dpkg pacman -Su

NOTES

  When being executed on Arch-based system, the tool simply invokes
  the system package manager (`/usr/bin/pacman`).

  Though you can specify option by its own word, for example,
      $ pacapt -S -y -u

  it's always the best to combine them
      $ pacapt -Syu

READMORE

  Please visit https://github.com/icy/pacapt.
EOF

}




_error() {
  echo >&2 ":: Error: $*"
  return 1
}

_warn() {
  echo >&2 ":: Warning: $*"
  return 0
}

_die() {
  echo >&2 ":: $*"
  exit 1
}

_debug() {
  if [ -n "${PACAPT_DEBUG:-}" ]; then
    >&2 echo ":: [debug] $*"
  fi
}

_not_implemented() {
  # shellcheck disable=2153
  echo >&2 "${_PACMAN}: '${_POPT}:${_SOPT}:${_TOPT}' operation is invalid or not implemented."
  return 1
}

_removing_is_dangerous() {
  echo >&2 "${_PACMAN}: removing with '$*' is too dangerous"
  return 1
}

_issue2pacman() {
  local_pacman="$1"; shift

  # The following line is added by Daniel YC Lin to support SunOS.
  #
  #   [ `uname` = "$1" ] && _PACMAN="$_pacman" && return
  #
  # This is quite tricky and fast, however I don't think it works
  # on Linux/BSD systems. To avoid extra check, I slightly modify
  # the code to make sure it's only applicable on SunOS.
  #
  [ "$(uname)" = "SunOS" ] && _PACMAN="$local_pacman" && return

  $GREP -qis "$@" /etc/issue \
  && _PACMAN="$local_pacman" && return

  $GREP -qis "$@" /etc/os-release \
  && _PACMAN="$local_pacman" && return
}

_PACMAN_detect() {
  _PACMAN_found_from_script_name && return

  _issue2pacman sun_tools "SunOS" && return
  _issue2pacman pacman "Arch Linux" && return
  _issue2pacman dpkg "Debian GNU/Linux" && return
  _issue2pacman dpkg "Ubuntu" && return
  _issue2pacman cave "Exherbo Linux" && return
  _issue2pacman yum "CentOS" && return
  _issue2pacman yum "Red Hat" && return
  #
  # FIXME: The multiple package issue.
  #
  # On #63, Huy commented out this line. This is because new generation
  # of Fedora uses `dnf`, and `yum` becomes a legacy tool. On old Fedora
  # system, `yum` is still detectable by looking up `yum` binary.
  #
  # I'm not sure how to support this case easily. Let's wait, e.g, 5 years
  # from now to make `dnf` becomes a default? Oh no!
  #
  # And here why `pacman` is still smart. Debian has a set of tools.
  # Fedora has `yum` (and a set of add-ons). Now Fedora moves to `dnf`.
  # This means that a package manager is not a heart of a system ;)
  #
  # _issue2pacman yum "Fedora" && return
  _issue2pacman zypper "SUSE" && return
  _issue2pacman pkg_tools "OpenBSD" && return
  _issue2pacman pkg_tools "Bitrig" && return
  _issue2pacman apk "Alpine Linux" && return
  _issue2pacman opkg "OpenWrt" && return

  [ -z "$_PACMAN" ] || return

  # Prevent a loop when this script is installed on non-standard system
  if [ -x "/usr/bin/pacman" ]; then
    $GREP -q "_PACMAN_detect" '/usr/bin/pacman' >/dev/null 2>&1
    [ $? -ge 1 ] && _PACMAN="pacman" \
    && return
  fi

  [ -x "/usr/bin/apt-get" ] && _PACMAN="dpkg" && return
  [ -x "/data/data/com.termux/files/usr/bin/apt-get" ] && _PACMAN="dpkg" && return
  [ -x "/usr/bin/cave" ] && _PACMAN="cave" && return
  [ -x "/usr/bin/dnf" ] && _PACMAN="dnf" && return
  [ -x "/usr/bin/yum" ] && _PACMAN="yum" && return
  [ -x "/opt/local/bin/port" ] && _PACMAN="macports" && return
  [ -x "/usr/bin/emerge" ] && _PACMAN="portage" && return
  [ -x "/usr/bin/zypper" ] && _PACMAN="zypper" && return
  [ -x "/usr/sbin/pkg" ] && _PACMAN="pkgng" && return
  # make sure pkg_add is after pkgng, FreeBSD base comes with it until converted
  [ -x "/usr/sbin/pkg_add" ] && _PACMAN="pkg_tools" && return
  [ -x "/usr/sbin/pkgadd" ] && _PACMAN="sun_tools" && return
  [ -x "/sbin/apk" ] && _PACMAN="apk" && return
  [ -x "/bin/opkg" ] && _PACMAN="opkg" && return
  [ -x "/usr/bin/tazpkg" ] && _PACMAN="tazpkg" && return
  [ -x "/usr/bin/swupd" ] && _PACMAN="swupd" && return

  command -v brew >/dev/null && _PACMAN="homebrew" && return

  return 1
}

_translate_w() {

  echo "$_EOPT" | $GREP -q ":w:" || return 0

  local_opt=
  local_ret=0

  case "$_PACMAN" in
  "dpkg")     local_opt="-d";;
  "cave")     local_opt="-f";;
  "dnf")      local_opt="--downloadonly";;
  "macports") local_opt="fetch";;
  "portage")  local_opt="--fetchonly";;
  "zypper")   local_opt="--download-only";;
  "pkgng")    local_opt="fetch";;
  "yum")      local_opt="--downloadonly";
    if ! rpm -q 'yum-downloadonly' >/dev/null 2>&1; then
      _error "'yum-downloadonly' package is required when '-w' is used."
      local_ret=1
    fi
    ;;
  "tazpkg")
    _error "$_PACMAN: Use '$_PACMAN get' to download and save packages to current directory."
    local_ret=1
    ;;
  "apk")      local_opt="fetch";;
  "opkg")     local_opt="--download-only";;
  *)
    local_opt=""
    local_ret=1

    _error "$_PACMAN: Option '-w' is not supported/implemented."
    ;;
  esac

  echo "$local_opt"
  return "$local_ret"
}

_translate_debug() {
  echo "$_EOPT" | $GREP -q ":v:" || return 0

  case "$_PACMAN" in
  "tazpkg")
    _error "$_PACMAN: Option '-v' (debug) is not supported/implemented by tazpkg"
    return 1
    ;;
  esac

  echo "-v"
}

_translate_noconfirm() {
  echo "$_EOPT" | $GREP -q ":noconfirm:" || return 0

  local_opt=
  local_ret=0

  case "$_PACMAN" in
  # FIXME: Update environment DEBIAN_FRONTEND=noninteractive
  # FIXME: There is also --force-yes for a stronger case
  "dpkg")   local_opt="--yes";;
  "dnf")    local_opt="--assumeyes";;
  "yum")    local_opt="--assumeyes";;
  # FIXME: pacman has 'assume-yes' and 'assume-no'
  # FIXME: zypper has better mode. Similar to dpkg (Debian).
  "zypper") local_opt="--no-confirm";;
  "pkgng")  local_opt="-y";;
  "tazpkg") local_opt="--auto";;
  "apk")    local_opt="";;
  *)
    local_opt=""
    local_ret=1
    _error "$_PACMAN: Option '--noconfirm' is not supported/implemented."
    ;;
  esac

  echo "$local_opt"
  return "$local_ret"
}

_translate_all() {
  local_args=""
  local_debug=
  local_noconfirm=

  local_debug="$(_translate_debug)" || return 1
  local_noconfirm="$(_translate_noconfirm)" || return 1
  local_args="$(_translate_w)" || return 1

  local_args="${local_args}${local_noconfirm:+ }${local_noconfirm}"
  local_args="${local_args}${local_debug:+ }${local_debug}"

  export _EOPT="${local_args# }"
}

_print_supported_operations() {
  local_pacman="$1"
  printf "pacapt(%s): available operations:" "$local_pacman"
  # shellcheck disable=2016
  $GREP -E "^(#_!_POSIX_# )?${local_pacman}_[^ \\t]+\\(\\)" "$0" \
  | $AWK -F '(' '{print $1}' \
  | sed -e "s/.*${local_pacman}_//g" \
  | while read -r O; do
      printf " %s" "$O"
    done
  echo
}

_quiet_field1() {
  if [ -z "${_TOPT}" ]; then
    cat
  else
    awk '{print $1}'
  fi
}

_string_nth() {
  local_idx="${1}"; shift
  local_args="${*}"

  local_args="${local_args}" local_idx="${local_idx}" \
  "$AWK" 'BEGIN{printf("%s",substr(ENVIRON["local_args"],ENVIRON["local_idx"],1))}'
}

_string_less_than() {
  a="${1}" b="${2}" "$AWK" 'BEGIN {exit !(ENVIRON["a"] < ENVIRON["b"]) }'
}


export _SUPPORTED_EXTERNALS="
  :conda
  :tlmgr
  :texlive
  :gem
  :npm
  :pip
"
readonly _SUPPORTED_EXTERNALS

_PACMAN_found_from_script_name() {
  local_tmp_name=
  local_pacman=

  local_tmp_name="${0}"
  # https://github.com/icy/pacapt/pull/161/files#r654800412
  case "$local_tmp_name" in
    *-*) : ;;
    *) return 1 ;;
  esac

  local_tmp_name="${local_tmp_name##*/}" # base name (remove everything before the last `/`)
  local_tmp_name="${local_tmp_name%.*}"  # remove extension if any (remove everything from the last `.`)
  local_pacman="${local_tmp_name##*-}"   # remove every thing before the last `-`

  if echo "$_SUPPORTED_EXTERNALS" \
    | "$GREP" -Eq -e ":${local_pacman}[[:space:]]*";
  then
    export _PACMAN="$local_pacman"
    return 0
  else
    export _PACMAN=""
    _die "Unable to guess non-system package manager ($local_pacman) from script name '$0'."
  fi
}



_apk_init() {
  :
}

apk_Q() {
  case "$_TOPT" in
  "")
    apk list --installed "$@"
    ;;
  "q")
    apk info
    ;;
  *)
    _not_implemented
    ;;
  esac
}

apk_Qi() {
  if [ "$#" -eq 0 ]; then
    # shellcheck disable=SC2046
    apk info --all $(apk info)
    return
  fi

  # shellcheck disable=2086
  if apk info --installed $_TOPT "$@"; then
    # shellcheck disable=2086
    apk info --all $_TOPT "$@"
  else
    >&2 echo ":: Error: Package not installed: '${*}'"
  fi
}

apk_Ql() {
  if [ "$#" -eq 0 ]; then
    packages="$(apk info)"
  else
    packages="$*"
  fi

  for pkg in ${packages:-}; do
    apk info --contents "$pkg" \
    | awk -v pkg="$pkg" '/\// {printf("%s %s\n", pkg, $0)}'
  done \
  | {
    case $_TOPT in
    "q") awk '{print $NF}';;
    "")  cat ;;
    *)   _not_implemented ; exit 1;;
    esac
  }
}

apk_Qo() {
  if cmd="$(command -v -- "$@")"; then
    apk info --who-owns -- "$cmd"
  else
    apk info --who-owns -- "$@"
  fi
}

apk_Qs() {
  # shellcheck disable=2086
  apk list --installed $_TOPT "*${*}*"
}

apk_Qu() {
  apk version -l '<'
}

apk_R() {
  # shellcheck disable=2086
  apk del $_TOPT -- "$@"
}

apk_Rn() {
  # shellcheck disable=2086
  apk del --purge $_TOPT -- "$@"
}

apk_Rns() {
  # shellcheck disable=2086
  apk del --purge -r $_TOPT -- "$@"
}

apk_Rs() {
  # shellcheck disable=2086
  apk del -r $_TOPT -- "$@"
}

apk_S() {
  # shellcheck disable=2086
  case ${_EOPT} in
    # Download only
    ("fetch") shift
              apk fetch $_TOPT -- "$@" ;;
          (*) apk add   $_TOPT -- "$@" ;;
  esac
}

apk_Sc() {
  apk cache -v clean
}

apk_Scc() {
  rm -rf /var/cache/apk/*
}

apk_Sccc() {
  apk_Scc
}

apk_Si() {
  # shellcheck disable=2086
  apk info $_TOPT "$@"
}

apk_Sii() {
  apk info -r -- "$@"
}

apk_Sl() {
  apk search -v -- "$@"
}

apk_Ss() {
  apk_Sl "$@"
}

apk_Su() {
  apk upgrade
}

apk_Suy() {
  if [ "$#" -gt 0 ]; then
    apk add -U -u -- "$@"
  else
    apk upgrade -U -a
  fi
}

apk_Sy() {
  apk update
}

apk_U() {
  # shellcheck disable=2086
  apk add --allow-untrusted $_TOPT -- "$@"
}
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _cave_init() {
#_!_POSIX_#   shopt -u globstar
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Q() {
#_!_POSIX_#   if [[ "$_TOPT" == "q" ]]; then
#_!_POSIX_#     cave show -f "${@:-world}" \
#_!_POSIX_#     | grep -v '^$'
#_!_POSIX_#   else
#_!_POSIX_#     cave show -f "${@:-world}"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Qi() {
#_!_POSIX_#   cave show "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Ql() {
#_!_POSIX_#   if [[ -n "$*" ]]; then
#_!_POSIX_#     cave contents "$@"
#_!_POSIX_#     return
#_!_POSIX_#   fi
#_!_POSIX_# 
#_!_POSIX_#   cave show -f "${@:-world}" \
#_!_POSIX_#   | grep -v '^$' \
#_!_POSIX_#   | while read -r _pkg; do
#_!_POSIX_#       if [[ "$_TOPT" == "q" ]]; then
#_!_POSIX_#         cave --color no contents "$_pkg"
#_!_POSIX_#       else
#_!_POSIX_#         cave contents "$_pkg"
#_!_POSIX_#       fi
#_!_POSIX_#     done
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Qo() {
#_!_POSIX_#   if cmd="$(command -v -- "$@")"; then
#_!_POSIX_#     cave owner "$cmd"
#_!_POSIX_#   else
#_!_POSIX_#     cave owner "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Qp() {
#_!_POSIX_#   _not_implemented
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Qu() {
#_!_POSIX_#   if [[ -z "$*" ]];then
#_!_POSIX_#     cave resolve -c world \
#_!_POSIX_#     | grep '^u.*' \
#_!_POSIX_#     | while read -r _pkg; do
#_!_POSIX_#         echo "$_pkg" | cut -d'u' -f2-
#_!_POSIX_#       done
#_!_POSIX_#   else
#_!_POSIX_#     cave resolve -c world \
#_!_POSIX_#     | grep '^u.*' \
#_!_POSIX_#     | grep -- "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Qs() {
#_!_POSIX_#   cave show -f world | grep -- "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Rs() {
#_!_POSIX_#   if [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     cave uninstall -r "$@" \
#_!_POSIX_#     && echo "Control-C to stop uninstalling..." \
#_!_POSIX_#     && sleep 2s \
#_!_POSIX_#     && cave uninstall -xr "$@"
#_!_POSIX_#   else
#_!_POSIX_#     cave purge "$@" \
#_!_POSIX_#     && echo "Control-C to stop uninstalling (+ dependencies)..." \
#_!_POSIX_#     && sleep 2s \
#_!_POSIX_#     && cave purge -x "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Rn() {
#_!_POSIX_#   _not_implemented
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Rns() {
#_!_POSIX_#   _not_implemented
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_R() {
#_!_POSIX_#   cave uninstall "$@" \
#_!_POSIX_#   && echo "Control-C to stop uninstalling..." \
#_!_POSIX_#   && sleep 2s \
#_!_POSIX_#   && cave uninstall -x "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Si() {
#_!_POSIX_#   cave show "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Suy() {
#_!_POSIX_#   cave sync && cave resolve -c "${@:-world}" \
#_!_POSIX_#   && echo "Control-C to stop upgrading..." \
#_!_POSIX_#   && sleep 2s \
#_!_POSIX_#   && cave resolve -cx "${@:-world}"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Su() {
#_!_POSIX_#   cave resolve -c "$@" \
#_!_POSIX_#   && echo "Control-C to stop upgrading..." \
#_!_POSIX_#   && sleep 2s \
#_!_POSIX_#   && cave resolve -cx "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Sy() {
#_!_POSIX_#   cave sync "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Ss() {
#_!_POSIX_#   cave search "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Sc() {
#_!_POSIX_#   cave fix-cache "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Scc() {
#_!_POSIX_#   cave fix-cache "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_Sccc() {
#_!_POSIX_#   #rm -fv /var/cache/paludis/*
#_!_POSIX_#   _not_implemented
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_S() {
#_!_POSIX_#   # shellcheck disable=SC2086
#_!_POSIX_#   cave resolve $_TOPT "$@" \
#_!_POSIX_#   && echo "Control-C to stop installing..." \
#_!_POSIX_#   && sleep 2s \
#_!_POSIX_#   && cave resolve -x $_TOPT "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# cave_U() {
#_!_POSIX_#   _not_implemented
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _conda_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# conda_Q() {
#_!_POSIX_#   if [[ $# -gt 0 ]]; then
#_!_POSIX_#     conda list "$(python -c 'import sys; print("^" + "|".join(sys.argv[1:]) + "$")' "$@")"
#_!_POSIX_#   else
#_!_POSIX_#     conda list
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# conda_R() {
#_!_POSIX_#   conda remove "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# conda_S() {
#_!_POSIX_#   conda install "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# conda_Sc() {
#_!_POSIX_#   conda clean --all "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# conda_Si() {
#_!_POSIX_#   conda search "$@" --info
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# conda_Ss() {
#_!_POSIX_#   conda search "*${*}*"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# conda_Suy() {
#_!_POSIX_#   conda update --all "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _dnf_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_S() {
#_!_POSIX_#   # shellcheck disable=SC2086
#_!_POSIX_#   dnf install $_TOPT "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Sc() {
#_!_POSIX_#   dnf clean expire-cache "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Scc() {
#_!_POSIX_#   dnf clean packages "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Sccc() {
#_!_POSIX_#   dnf clean all "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Si() {
#_!_POSIX_#   dnf info "$@" && dnf repoquery --deplist "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Sg() {
#_!_POSIX_#   if [[ $# -gt 0 ]]; then
#_!_POSIX_#     dnf group info "$@"
#_!_POSIX_#   else
#_!_POSIX_#     dnf group list
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Sl() {
#_!_POSIX_#   dnf list available "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Ss() {
#_!_POSIX_#   dnf search "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Su() {
#_!_POSIX_#   dnf upgrade "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Suy() {
#_!_POSIX_#   dnf upgrade "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Sy() {
#_!_POSIX_#   dnf clean expire-cache && dnf check-update
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Q() {
#_!_POSIX_#   if [[ "$_TOPT" == "q" ]]; then
#_!_POSIX_#     rpm -qa --qf "%{NAME}\\n"
#_!_POSIX_#   elif [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     rpm -qa --qf "%{NAME} %{VERSION}\\n"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Qc() {
#_!_POSIX_#   rpm -q --changelog "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Qe() {
#_!_POSIX_#   dnf repoquery --userinstalled "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Qi() {
#_!_POSIX_#   dnf info --installed "$@" && dnf repoquery --deplist "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Ql() {
#_!_POSIX_#   rpm -ql "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Qm() {
#_!_POSIX_#   dnf list extras
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Qo() {
#_!_POSIX_#   if cmd="$(command -v -- "$@")"; then
#_!_POSIX_#     rpm -qf "$cmd"
#_!_POSIX_#   else
#_!_POSIX_#     rpm -qf "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Qp() {
#_!_POSIX_#   rpm -qp "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Qs() {
#_!_POSIX_#   rpm -qa "*${*}*"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_Qu() {
#_!_POSIX_#   dnf list updates "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_R() {
#_!_POSIX_#   dnf remove "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dnf_U() {
#_!_POSIX_#   dnf install "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _dpkg_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Q() {
#_!_POSIX_#   if [[ "$_TOPT" == "q" ]]; then
#_!_POSIX_#     dpkg -l \
#_!_POSIX_#     | grep -E '^[hi]i' \
#_!_POSIX_#     | awk '{print $2}'
#_!_POSIX_#   elif [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     dpkg -l "$@" \
#_!_POSIX_#     | grep -E '^[hi]i'
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Qi() {
#_!_POSIX_#   dpkg-query -s "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Ql() {
#_!_POSIX_#   if [[ -n "$*" ]]; then
#_!_POSIX_#     dpkg-query -L "$@"
#_!_POSIX_#     return
#_!_POSIX_#   fi
#_!_POSIX_# 
#_!_POSIX_#   dpkg -l \
#_!_POSIX_#   | grep -E '^[hi]i' \
#_!_POSIX_#   | awk '{print $2}' \
#_!_POSIX_#   | while read -r _pkg; do
#_!_POSIX_#       if [[ "$_TOPT" == "q" ]]; then
#_!_POSIX_#         dpkg-query -L "$_pkg"
#_!_POSIX_#       else
#_!_POSIX_#         dpkg-query -L "$_pkg" \
#_!_POSIX_#         | while read -r _line; do
#_!_POSIX_#             echo "$_pkg $_line"
#_!_POSIX_#           done
#_!_POSIX_#       fi
#_!_POSIX_#     done
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Qo() {
#_!_POSIX_#   if cmd="$(command -v -- "$@")"; then
#_!_POSIX_#     dpkg-query -S "$cmd"
#_!_POSIX_#   else
#_!_POSIX_#     dpkg-query -S "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Qp() {
#_!_POSIX_#   dpkg-deb -I "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Qu() {
#_!_POSIX_#   apt-get upgrade --trivial-only "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Qs() {
#_!_POSIX_#   # dpkg >= 1.16.2 dpkg-query -W -f='${db:Status-Abbrev} ${binary:Package}\t${Version}\t${binary:Summary}\n'
#_!_POSIX_#   dpkg-query -W -f='${Status} ${Package}\t${Version}\t${Description}\n' \
#_!_POSIX_#   | grep -E '^((hold)|(install)|(deinstall))' \
#_!_POSIX_#   | sed -r -e 's#^(\w+ ){3}##g' \
#_!_POSIX_#   | grep -Ei "${@:-.}" \
#_!_POSIX_#   | _quiet_field1
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Rs() {
#_!_POSIX_#   if [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     apt-get autoremove "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Rn() {
#_!_POSIX_#   apt-get purge "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Rns() {
#_!_POSIX_#   apt-get --purge autoremove "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_R() {
#_!_POSIX_#   apt-get remove "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Si() {
#_!_POSIX_#   apt-cache show "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Suy() {
#_!_POSIX_#   apt-get update \
#_!_POSIX_#   && apt-get upgrade "$@" \
#_!_POSIX_#   && apt-get dist-upgrade "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Su() {
#_!_POSIX_#   apt-get upgrade "$@" \
#_!_POSIX_#   && apt-get dist-upgrade "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# dpkg_Sy() {
#_!_POSIX_#   apt-get update "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Ss() {
#_!_POSIX_#   local IFS=$'\n'
#_!_POSIX_#   packages=($(apt-cache search "$@"))
#_!_POSIX_#   for package in ${packages[@]:-}
#_!_POSIX_#   do
#_!_POSIX_#     name=${package%% - *}
#_!_POSIX_#     desc=${package#* - }
#_!_POSIX_#     dpkg-query -W "$name" > /dev/null 2>&1
#_!_POSIX_#     if [[ $? -eq 1 ]]; then
#_!_POSIX_#       echo -e "package/$name \n    $desc"
#_!_POSIX_#     else
#_!_POSIX_#       dpkg-query -W -f='package/${binary:Package} ${Version}\t[${Status}]\n    ${binary:Summary}\n' "$name"
#_!_POSIX_#     fi
#_!_POSIX_#   done
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Sc() {
#_!_POSIX_#   apt-get clean "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Scc() {
#_!_POSIX_#   apt-get autoclean "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_S() {
#_!_POSIX_#   apt-get install $_TOPT "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_U() {
#_!_POSIX_#   dpkg -i "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Sii() {
#_!_POSIX_#   apt-cache rdepends "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# dpkg_Sccc() {
#_!_POSIX_#   rm -fv /var/cache/apt/*.bin
#_!_POSIX_#   rm -fv /var/cache/apt/archives/*.*
#_!_POSIX_#   rm -fv /var/lib/apt/lists/*.*
#_!_POSIX_#   apt-get autoclean
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _homebrew_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Qi() {
#_!_POSIX_#   brew info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Ql() {
#_!_POSIX_#   brew list "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Qo() {
#_!_POSIX_#   local pkg prefix cellar
#_!_POSIX_# 
#_!_POSIX_#   # FIXME: What happens if the file is not exectutable?
#_!_POSIX_#   cd "$(dirname -- "$(which "$@")")" || return
#_!_POSIX_#   pkg="$(pwd -P)/$(basename -- "$@")"
#_!_POSIX_#   prefix="$(brew --prefix)"
#_!_POSIX_#   cellar="$(brew --cellar)"
#_!_POSIX_# 
#_!_POSIX_#   for package in "$cellar"/*; do
#_!_POSIX_#     files=(${package}/*/${pkg/#$prefix\//})
#_!_POSIX_#     if [[ -e "${files[${#files[@]} - 1]}" ]]; then
#_!_POSIX_#       echo "${package/#$cellar\//}"
#_!_POSIX_#       break
#_!_POSIX_#     fi
#_!_POSIX_#   done
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Qc() {
#_!_POSIX_#   brew log "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Qu() {
#_!_POSIX_#   brew outdated | grep "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Qs() {
#_!_POSIX_#   brew list | grep "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Q() {
#_!_POSIX_#   if [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     if [[ "$*" == "" ]]; then
#_!_POSIX_#       brew list
#_!_POSIX_#     else
#_!_POSIX_#       brew list | grep "$@"
#_!_POSIX_#     fi
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Rs() {
#_!_POSIX_#     if ! which join > /dev/null 2>&1; then
#_!_POSIX_#       _die "pacapt: join binary does not exist in system."
#_!_POSIX_#     fi
#_!_POSIX_# 
#_!_POSIX_#     if ! which sort > /dev/null 2>&1; then
#_!_POSIX_#       _die "pacapt: sort binary does not exist in system."
#_!_POSIX_#     fi
#_!_POSIX_# 
#_!_POSIX_#     if [[ -z "$*" ]]; then
#_!_POSIX_#       _die "pacapt: ${FUNCNAME[0]} requires arguments"
#_!_POSIX_#     fi
#_!_POSIX_# 
#_!_POSIX_#     for _target in "${@}";
#_!_POSIX_#     do
#_!_POSIX_#       brew rm "$_target"
#_!_POSIX_# 
#_!_POSIX_#       while [ "$(join <(sort <(brew leaves)) <(sort <(brew deps $_target)))" != "" ]
#_!_POSIX_#       do
#_!_POSIX_#         brew rm $(join <(sort <(brew leaves)) <(sort <(brew deps $_target)))
#_!_POSIX_#       done
#_!_POSIX_#     done
#_!_POSIX_# 
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_R() {
#_!_POSIX_#   brew remove "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Si() {
#_!_POSIX_#   brew info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Suy() {
#_!_POSIX_#   brew update \
#_!_POSIX_#   && brew upgrade "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Su() {
#_!_POSIX_#   brew upgrade "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Sy() {
#_!_POSIX_#   brew update "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Ss() {
#_!_POSIX_#   brew search "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Sc() {
#_!_POSIX_#   brew cleanup "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Scc() {
#_!_POSIX_#   brew cleanup -s "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_Sccc() {
#_!_POSIX_#   # See more discussion in
#_!_POSIX_#   #   https://github.com/icy/pacapt/issues/47
#_!_POSIX_# 
#_!_POSIX_#   local _dcache
#_!_POSIX_# 
#_!_POSIX_#   _dcache="$(brew --cache)"
#_!_POSIX_#   case "$_dcache" in
#_!_POSIX_#   ""|"/"|" ")
#_!_POSIX_#     _error "${FUNCNAME[0]}: Unable to delete '$_dcache'."
#_!_POSIX_#     ;;
#_!_POSIX_# 
#_!_POSIX_#   *)
#_!_POSIX_#     # FIXME: This is quite stupid!!! But it's an easy way
#_!_POSIX_#     # FIXME: to avoid some warning from #shellcheck.
#_!_POSIX_#     # FIXME: Please note that, $_dcache is not empty now.
#_!_POSIX_#     rm -rf "${_dcache:-/x/x/x/x/x/x/x/x/x/x/x//x/x/x/x/x/}/"
#_!_POSIX_#     ;;
#_!_POSIX_#   esac
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# homebrew_S() {
#_!_POSIX_#   # shellcheck disable=SC2086
#_!_POSIX_#   2>&1 brew install $_TOPT "$@" \
#_!_POSIX_#   | awk '{print; if ($0 ~ /brew cask install/) { exit(126); }}'
#_!_POSIX_#   ret=( ${PIPESTATUS[*]} )
#_!_POSIX_#   if [[ "${ret[1]}" == 126 ]]; then
#_!_POSIX_#     echo >&2 ":: Now trying with brew/cask..."
#_!_POSIX_#     # shellcheck disable=SC2086
#_!_POSIX_#     brew cask install $_TOPT "$@"
#_!_POSIX_#   else
#_!_POSIX_#     return "${ret[0]}"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _macports_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Ql() {
#_!_POSIX_#   port contents "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Qo() {
#_!_POSIX_#   if cmd="$(command -v -- "$@")"; then
#_!_POSIX_#     port provides "$cmd"
#_!_POSIX_#   else
#_!_POSIX_#     port provides "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Qc() {
#_!_POSIX_#   port log "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Qu() {
#_!_POSIX_#   port outdated "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Rs() {
#_!_POSIX_#   if [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     port uninstall --follow-dependencies "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_R() {
#_!_POSIX_#   port uninstall "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Si() {
#_!_POSIX_#   port info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Suy() {
#_!_POSIX_#   port selfupdate \
#_!_POSIX_#   && port upgrade outdated "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Su() {
#_!_POSIX_#   port upgrade outdate "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Sy() {
#_!_POSIX_#   port selfupdate "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Ss() {
#_!_POSIX_#   port search "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Sc() {
#_!_POSIX_#   port clean --all inactive "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_Scc() {
#_!_POSIX_#   port clean --all installed "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# macports_S() {
#_!_POSIX_#   if [[ "$_TOPT" == "fetch" ]]; then
#_!_POSIX_#     port patch "$@"
#_!_POSIX_#   else
#_!_POSIX_#     port install "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }



_opkg_init() {
  :
}

opkg_Sy() {
  opkg update
}

opkg_Q() {
  # shellcheck disable=SC2016
  case "$_TOPT" in
  "q")
    opkg list-installed "$@" | "$AWK" '{print $1}'
    ;;
  "")
    opkg list-installed "$@"
    ;;
  *)
    _not_implemented
    ;;
  esac
}

opkg_Qi() {
  for  pkg in $(opkg__get_local_pkgs "${@}"); do
    opkg info "$pkg"
  done
}

opkg__get_local_pkgs() {
  if [ "$#" -eq 0 ]; then
    # shellcheck disable=SC2016
    opkg list-installed | "$AWK" '{print $1}'
  else
    # `opkg status` returns empty if package is not installed/removed.
    # shellcheck disable=SC2016
    for pkg in "${@}"; do
      opkg status "$pkg"
    done \
    | "$AWK" '/^Package: / {print $NF}'
  fi
}

opkg_Ql() {
  for pkg in $(opkg__get_local_pkgs "${@}"); do
    # shellcheck disable=SC2016
    opkg files "$pkg" \
    | PKG="$pkg" "$AWK" \
        '{ if (NR>1) {printf("%s %s\n", ENVIRON["PKG"], $0)} }'
  done
}

opkg_Qo() {
  if cmd="$(command -v -- "$@")"; then
    opkg search "$cmd"
  else
    opkg search "$@"
  fi
}

opkg_Qs() {
  if command -v sort >/dev/null; then
    local_filter="sort -u"
  else
    local_filter="cat"
  fi

  # FIXME: opkg doesn't work with wildcard by default.
  case "$@" in
  *\**) local_pattern="$*" ;;
  *)    local_pattern="*${*}*" ;;
  esac

  opkg search "$local_pattern" \
  | ${local_filter} \
  | _quiet_field1
}

opkg_Qu() {
  opkg list-upgradable
}

opkg_R() {
  opkg remove "$@"
}

opkg_S() {
  opkg install "$@"
}

opkg_Si() {
  # shellcheck disable=2086
  opkg list $_TOPT "$@"
}

opkg_Sii() {
  # shellcheck disable=2086
  opkg list $_TOPT "$@"
  opkg whatdepends "$@"
}

opkg_Ss() {
  opkg list "$@"
}

opkg_Su() {
  opkg upgrade "$@"
}

opkg_U() {
  opkg install "$@"
}
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _pkgng_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Qi() {
#_!_POSIX_#   pkg info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Ql() {
#_!_POSIX_#   pkg info -l "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Qo() {
#_!_POSIX_#   if cmd="$(command -v -- "$@")"; then
#_!_POSIX_#     pkg which "$cmd"
#_!_POSIX_#   else
#_!_POSIX_#     pkg which "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Qp() {
#_!_POSIX_#   pkg query -F "$@" '%n %v'
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Qu() {
#_!_POSIX_#   pkg upgrade -n "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Q() {
#_!_POSIX_#   if [[ "$_TOPT" == "q" ]]; then
#_!_POSIX_#     pkg query '%n' "$@"
#_!_POSIX_#   elif [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     pkg query '%n %v' "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Rs() {
#_!_POSIX_#   if [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     pkg remove "$@"
#_!_POSIX_#     pkg autoremove
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_R() {
#_!_POSIX_#   pkg remove "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Si() {
#_!_POSIX_#   pkg search -S name -ef "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Suy() {
#_!_POSIX_#   pkg upgrade "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Su() {
#_!_POSIX_#   pkg upgrade -U "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Sy() {
#_!_POSIX_#   pkg update "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Ss() {
#_!_POSIX_#   pkg search "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Sc() {
#_!_POSIX_#   pkg clean "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_Scc() {
#_!_POSIX_#   pkg clean -a "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkgng_S() {
#_!_POSIX_#   if [[ "$_TOPT" == "fetch" ]]; then
#_!_POSIX_#     pkg fetch "$@"
#_!_POSIX_#   else
#_!_POSIX_#     pkg install "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _pkg_tools_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Qi() {
#_!_POSIX_#   # disable searching mirrors for packages
#_!_POSIX_#   export PKG_PATH=
#_!_POSIX_#   pkg_info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Ql() {
#_!_POSIX_#   export PKG_PATH=
#_!_POSIX_#   pkg_info -L "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Qo() {
#_!_POSIX_#   export PKG_PATH=
#_!_POSIX_#   if cmd="$(command -v -- "$@")"; then
#_!_POSIX_#     pkg_info -E "$cmd"
#_!_POSIX_#   else
#_!_POSIX_#     pkg_info -E "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Qp() {
#_!_POSIX_#   _not_implemented
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Qu() {
#_!_POSIX_#   export PKG_PATH=
#_!_POSIX_#   pkg_add -u "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Q() {
#_!_POSIX_#   export PKG_PATH=
#_!_POSIX_#   # the dash after the pkg name is so we don't catch partial matches
#_!_POSIX_#   # because all packages in openbsd have the format 'pkgname-pkgver'
#_!_POSIX_#   if [[ "$_TOPT" == "q" && -n "$*" ]]; then
#_!_POSIX_#     pkg_info -q | grep "^${*}-"
#_!_POSIX_#   elif [[ "$_TOPT" == "q" && -z "$*" ]];then
#_!_POSIX_#     pkg_info -q
#_!_POSIX_#   elif [[ "$_TOPT" == "" && -n "$*" ]]; then
#_!_POSIX_#     pkg_info | grep "^${*}-"
#_!_POSIX_#   elif [[ "$_TOPT" == "" && -z "$*" ]];then
#_!_POSIX_#     pkg_info
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Rs() {
#_!_POSIX_#   if [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     pkg_delete -D dependencies "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Rn() {
#_!_POSIX_#   if [[ "$_TOPT" == "" ]];then
#_!_POSIX_#     pkg_delete -c "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Rns() {
#_!_POSIX_#   _not_implemented
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_R() {
#_!_POSIX_#   pkg_delete "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Si() {
#_!_POSIX_#   pkg_info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Sl() {
#_!_POSIX_#   pkg_info -L "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Suy() {
#_!_POSIX_#   # pkg_tools doesn't really have any concept of a database
#_!_POSIX_#   # there's actually not really any database to update, so
#_!_POSIX_#   # this function is mostly just for convienience since on arch
#_!_POSIX_#   # doing -Su is normally a bad thing to do since it's a partial upgrade
#_!_POSIX_# 
#_!_POSIX_#   pkg_tools_Su "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Su() {
#_!_POSIX_#   pkg_add -u "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Sy() {
#_!_POSIX_#   _not_implemented
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Ss() {
#_!_POSIX_#   if [[ -z "$*" ]];then
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   else
#_!_POSIX_#     pkg_info -Q "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Sc() {
#_!_POSIX_#   # by default no cache directory is used
#_!_POSIX_#   if [[ -z "$PKG_CACHE" ]];then
#_!_POSIX_#     echo "You have no cache directory set, set \$PKG_CACHE for a cache directory."
#_!_POSIX_#   elif [[ ! -d "$PKG_CACHE" ]];then
#_!_POSIX_#     echo "You have a cache directory set, but it does not exist. Create \"$PKG_CACHE\"."
#_!_POSIX_#   else
#_!_POSIX_#     _removing_is_dangerous "rm -rf $PKG_CACHE/*"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_Scc() {
#_!_POSIX_#   _not_implemented
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# pkg_tools_S() {
#_!_POSIX_#   pkg_add "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _portage_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Qi() {
#_!_POSIX_#   emerge --info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Ql() {
#_!_POSIX_#   if [[ -x '/usr/bin/qlist' ]]; then
#_!_POSIX_#     qlist "$@"
#_!_POSIX_#   elif [[ -x '/usr/bin/equery' ]]; then
#_!_POSIX_#     equery files "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _error "'portage-utils' or 'gentoolkit' package is required to perform this opreation."
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Qo() {
#_!_POSIX_#   if [[ -x '/usr/bin/equery' ]]; then
#_!_POSIX_#     if cmd="$(command -v -- "$@")"; then
#_!_POSIX_#       equery belongs "$cmd"
#_!_POSIX_#     else
#_!_POSIX_#       equery belongs "$@"
#_!_POSIX_#     fi
#_!_POSIX_#   else
#_!_POSIX_#     _error "'gentoolkit' package is required to perform this operation."
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Qc() {
#_!_POSIX_#   emerge -p --changelog "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Qu() {
#_!_POSIX_#   emerge -uvN "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Q() {
#_!_POSIX_#   if [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     if [[ -x '/usr/bin/eix' ]]; then
#_!_POSIX_#       eix -I "$@"
#_!_POSIX_#     elif [[ -x '/usr/bin/equery' ]]; then
#_!_POSIX_#       equery list -i "$@"
#_!_POSIX_#     else
#_!_POSIX_#       LS_COLORS=never \
#_!_POSIX_#       ls -1 -d /var/db/pkg/*/*
#_!_POSIX_#     fi
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Rs() {
#_!_POSIX_#   if [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     emerge --depclean world "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_R() {
#_!_POSIX_#   emerge --depclean "@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Si() {
#_!_POSIX_#   emerge --info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Suy() {
#_!_POSIX_#   if [[ -x '/usr/bin/layman' ]]; then
#_!_POSIX_#     layman --sync-all \
#_!_POSIX_#     && emerge --sync \
#_!_POSIX_#     && emerge -auND world "$@"
#_!_POSIX_#   else
#_!_POSIX_#     emerge --sync \
#_!_POSIX_#     && emerge -uND world "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Su() {
#_!_POSIX_#   emerge -uND world "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Sy() {
#_!_POSIX_#   if [[ -x "/usr/bin/layman" ]]; then
#_!_POSIX_#     layman --sync-all \
#_!_POSIX_#     && emerge --sync "$@"
#_!_POSIX_#   else
#_!_POSIX_#     emerge --sync "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Ss() {
#_!_POSIX_#   if [[ -x "/usr/bin/eix" ]]; then
#_!_POSIX_#     eix "$@"
#_!_POSIX_#   else
#_!_POSIX_#     emerge --search "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Sc() {
#_!_POSIX_#   if [[ -x "/usr/bin/eclean-dist" ]]; then
#_!_POSIX_#     eclean-dist -d -t1m -s50 -f "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _error "'gentoolkit' package is required to perform this operation."
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Scc() {
#_!_POSIX_#   if [[ -x "/usr/bin/eclean" ]]; then
#_!_POSIX_#     eclean -i distfiles "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _error "'gentoolkit' package is required to perform this operation."
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_Sccc() {
#_!_POSIX_#   rm -fv /usr/portage/distfiles/*.*
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# portage_S() {
#_!_POSIX_#   emerge "$@"
#_!_POSIX_# }



_sun_tools_init() {
  # The purpose of `if` is to make sure this function
  # can be invoked on other system (Linux, BSD).
  if [ "$(uname)" = "SunOS" ]; then
    export GREP=/usr/xpg4/bin/grep
    export AWK=nawk
    return 0
  fi
  return 1
}

sun_tools_Qi() {
  pkginfo -l "$@"
}

sun_tools_Ql() {
  pkginfo -l "$@"
}

sun_tools_Qo() {
  if cmd="$(command -v -- "$@")"; then
    $GREP "$cmd" /var/sadm/install/contents
  else
    $GREP "$@" /var/sadm/install/contents
  fi
}

sun_tools_Qs() {
  pkginfo | $GREP -i "$@"
}

sun_tools_Q() {
  # the dash after the pkg name is so we don't catch partial matches
  # because all packages in openbsd have the format 'pkgname-pkgver'
  if [ "$_TOPT" = "q" ] && [ -n "$*" ]; then
    pkginfo | $GREP "$@"
  elif [ "$_TOPT" = "q" ] && [ -z "$*" ]; then
    pkginfo
  else
    pkginfo "$@"
  fi
}

sun_tools_R() {
  pkgrm "$@"
}

sun_tools_U() {
  pkgadd "$@"
}
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _swupd_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# swupd_Qk() {
#_!_POSIX_#   swupd verify "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# swupd_Qo() {
#_!_POSIX_#   if cmd="$(command -v -- "$@")"; then
#_!_POSIX_#     swupd search "$cmd"
#_!_POSIX_#   else
#_!_POSIX_#     swupd search "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# swupd_Qs() {
#_!_POSIX_#   swupd search "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# swupd_R() {
#_!_POSIX_#   swupd bundle-remove "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# swupd_Suy() {
#_!_POSIX_#   swupd update
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# swupd_Su() {
#_!_POSIX_#   swupd update
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# swupd_Sy() {
#_!_POSIX_#   swupd search -i
#_!_POSIX_#   swupd update
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# swupd_Ss() {
#_!_POSIX_#   swupd search "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# swupd_S() {
#_!_POSIX_#   swupd bundle-add "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _tazpkg_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_Q() {
#_!_POSIX_#   if [[ "$_TOPT" == "q" ]]; then
#_!_POSIX_#     tazpkg list "$@" \
#_!_POSIX_#     | awk '{ if (NF == 2 || NF == 3) { print $1; }}'
#_!_POSIX_#   elif [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     tazpkg list "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_Qi() {
#_!_POSIX_#   tazpkg info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_Ql() {
#_!_POSIX_#   if [[ -z "$*" ]]; then
#_!_POSIX_#     _not_implemented
#_!_POSIX_#     return
#_!_POSIX_#   fi
#_!_POSIX_# 
#_!_POSIX_#   if [[ "$_TOPT" == "q" ]]; then
#_!_POSIX_#     {
#_!_POSIX_#       tazpkg list-files "$@"
#_!_POSIX_#       tazpkg list-config "$@"
#_!_POSIX_#     } \
#_!_POSIX_#     | grep ^/
#_!_POSIX_#   else
#_!_POSIX_#     tazpkg list-files "$@"
#_!_POSIX_#     tazpkg list-config "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_Sy() {
#_!_POSIX_#   tazpkg recharge
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_Su() {
#_!_POSIX_#   tazpkg up
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_Suy() {
#_!_POSIX_#   tazpkg_Sy \
#_!_POSIX_#   && tazpkg_Su
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_S() {
#_!_POSIX_#   local _forced=""
#_!_POSIX_# 
#_!_POSIX_#   if grep -q -- "--forced" <<<"$*"; then
#_!_POSIX_#     _forced="--forced"
#_!_POSIX_#   fi
#_!_POSIX_# 
#_!_POSIX_#   while (( $# )); do
#_!_POSIX_#     if [[ "$1" == "--forced" ]]; then
#_!_POSIX_#       _forced="--forced"
#_!_POSIX_#       shift
#_!_POSIX_#       continue
#_!_POSIX_#     fi
#_!_POSIX_# 
#_!_POSIX_#     tazpkg get-install "$1" $_forced
#_!_POSIX_#     shift
#_!_POSIX_#   done
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_R() {
#_!_POSIX_#   local _auto=""
#_!_POSIX_# 
#_!_POSIX_#   if grep -q -- "--auto" <<<"$*"; then
#_!_POSIX_#     _auto="--auto"
#_!_POSIX_#   fi
#_!_POSIX_# 
#_!_POSIX_#   while (( $# )); do
#_!_POSIX_#     if [[ "$1" == "--auto" ]]; then
#_!_POSIX_#       _auto="--auto"
#_!_POSIX_#       shift
#_!_POSIX_#       continue
#_!_POSIX_#     fi
#_!_POSIX_# 
#_!_POSIX_#     tazpkg remove "$1" $_auto
#_!_POSIX_#     shift
#_!_POSIX_#   done
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_Sc() {
#_!_POSIX_#   tazpkg clean-cache
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_Scc() {
#_!_POSIX_#   tazpkg clean-cache
#_!_POSIX_#   cd /var/lib/tazpkg/ \
#_!_POSIX_#   && {
#_!_POSIX_#     rm -fv \
#_!_POSIX_#       ./*.bak \
#_!_POSIX_#       ID \
#_!_POSIX_#       packages.* \
#_!_POSIX_#       files.list.*
#_!_POSIX_#   }
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_Ss() {
#_!_POSIX_#   tazpkg search "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_Qo() {
#_!_POSIX_#   if cmd="$(command -v -- "$@")"; then
#_!_POSIX_#     tazpkg search-pkgname "$cmd"
#_!_POSIX_#   else
#_!_POSIX_#     tazpkg search-pkgname "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tazpkg_U() {
#_!_POSIX_#   local _forced=""
#_!_POSIX_# 
#_!_POSIX_#   if grep -q -- "--forced" <<<"$*"; then
#_!_POSIX_#     _forced="--forced"
#_!_POSIX_#   fi
#_!_POSIX_# 
#_!_POSIX_#   while (( $# )); do
#_!_POSIX_#     if [[ "$1" == "--forced" ]]; then
#_!_POSIX_#       _forced="--forced"
#_!_POSIX_#       shift
#_!_POSIX_#       continue
#_!_POSIX_#     fi
#_!_POSIX_# 
#_!_POSIX_#     tazpkg install "$1" $_forced
#_!_POSIX_#     shift
#_!_POSIX_#   done
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _tlmgr_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tlmgr_Qi() {
#_!_POSIX_#   tlmgr info --only-installed "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tlmgr_Qk() {
#_!_POSIX_#   tlmgr check files
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tlmgr_Ql() {
#_!_POSIX_#   tlmgr info --only-installed --list "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tlmgr_R() {
#_!_POSIX_#   tlmgr remove "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tlmgr_S() {
#_!_POSIX_#   tlmgr install "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tlmgr_Si() {
#_!_POSIX_#   tlmgr info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tlmgr_Sl() {
#_!_POSIX_#   tlmgr info
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tlmgr_Ss() {
#_!_POSIX_#   tlmgr search --global "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tlmgr_Suy() {
#_!_POSIX_#   tlmgr update --all
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# tlmgr_U() {
#_!_POSIX_#   tlmgr install --file "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _yum_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Q() {
#_!_POSIX_#   if [[ "$_TOPT" == "q" ]]; then
#_!_POSIX_#     rpm -qa --qf "%{NAME}\\n"
#_!_POSIX_#   elif [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     rpm -qa --qf "%{NAME} %{VERSION}\\n"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Qi() {
#_!_POSIX_#   yum info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Qs() {
#_!_POSIX_#   if [[ "$_TOPT" == "q" ]]; then
#_!_POSIX_#     rpm -qa --qf "%{NAME}\\n" "*${*}*"
#_!_POSIX_#   elif [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     rpm -qa --qf "%{NAME} %{VERSION}\\n" "*${*}*"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Ql() {
#_!_POSIX_#   rpm -ql "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Qo() {
#_!_POSIX_#   if cmd="$(command -v -- "$@")"; then
#_!_POSIX_#     rpm -qf "$cmd"
#_!_POSIX_#   else
#_!_POSIX_#     rpm -qf "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Qp() {
#_!_POSIX_#   rpm -qp "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Qc() {
#_!_POSIX_#   rpm -q --changelog "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Qu() {
#_!_POSIX_#   yum list updates "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Qm() {
#_!_POSIX_#   yum list extras "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Rs() {
#_!_POSIX_#   if [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     yum erase "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_R() {
#_!_POSIX_#   yum erase "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Si() {
#_!_POSIX_#   yum info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Suy() {
#_!_POSIX_#   yum update "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Su() {
#_!_POSIX_#   yum update "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Sy() {
#_!_POSIX_#   yum check-update "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Ss() {
#_!_POSIX_#   yum -C search "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Sc() {
#_!_POSIX_#   yum clean expire-cache "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Scc() {
#_!_POSIX_#   yum clean packages "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Sccc() {
#_!_POSIX_#   yum clean all "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_S() {
#_!_POSIX_#   # shellcheck disable=SC2086
#_!_POSIX_#   yum install $_TOPT "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_U() {
#_!_POSIX_#   yum localinstall "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# yum_Sii() {
#_!_POSIX_#   yum resolvedep "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# 
#_!_POSIX_# _zypper_init() {
#_!_POSIX_#   :
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Qc() {
#_!_POSIX_#   rpm -q --changelog "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Qi() {
#_!_POSIX_#   zypper info "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Ql() {
#_!_POSIX_#   rpm -ql "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Qu() {
#_!_POSIX_#   zypper list-updates "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Qm() {
#_!_POSIX_#   zypper search -si "$@" \
#_!_POSIX_#   | grep 'System Packages'
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Qo() {
#_!_POSIX_#   if cmd="$(command -v -- "$@")"; then
#_!_POSIX_#     rpm -qf "$cmd"
#_!_POSIX_#   else
#_!_POSIX_#     rpm -qf "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Qp() {
#_!_POSIX_#   rpm -qip "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Qs() {
#_!_POSIX_#   zypper search --installed-only "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Q() {
#_!_POSIX_#   if [[ "$_TOPT" == "q" ]]; then
#_!_POSIX_#     zypper search -i "$@" \
#_!_POSIX_#     | grep ^i \
#_!_POSIX_#     | awk '{print $3}'
#_!_POSIX_#   elif [[ "$_TOPT" == "" ]]; then
#_!_POSIX_#     zypper search -i "$@"
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Rs() {
#_!_POSIX_#   if [[ "$_TOPT" == "s" ]]; then
#_!_POSIX_#     zypper remove "$@" --clean-deps
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_R() {
#_!_POSIX_#   zypper remove "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Rn() {
#_!_POSIX_#   # Remove configuration files
#_!_POSIX_#   while read -r file; do
#_!_POSIX_#     if [[ -f "$file" ]]; then
#_!_POSIX_#       rm -fv "$file"
#_!_POSIX_#     fi
#_!_POSIX_#   done < <(rpm -ql "$@")
#_!_POSIX_# 
#_!_POSIX_#   # Now remove the package per-se
#_!_POSIX_#   zypper remove "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Rs() {
#_!_POSIX_#   if [[ "$_TOPT" == "s" ]]; then
#_!_POSIX_#     zypper remove "$@" --clean-deps
#_!_POSIX_#   else
#_!_POSIX_#     _not_implemented
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Rns() {
#_!_POSIX_#   # Remove configuration files
#_!_POSIX_#   while read -r file; do
#_!_POSIX_#     if [[ -f "$file" ]]; then
#_!_POSIX_#       rm -fv "$file"
#_!_POSIX_#     fi
#_!_POSIX_#   done < <(rpm -ql "$@")
#_!_POSIX_# 
#_!_POSIX_#   zypper remove "$@" --clean-deps
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Suy() {
#_!_POSIX_#   zypper dup "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Sy() {
#_!_POSIX_#   zypper refresh "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Sl() {
#_!_POSIX_#   if [[ $# -eq 0 ]]; then
#_!_POSIX_#     zypper pa -R
#_!_POSIX_#   else
#_!_POSIX_#     zypper pa -r "$@"
#_!_POSIX_#   fi
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Ss() {
#_!_POSIX_#   zypper search "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Su() {
#_!_POSIX_#   zypper --no-refresh dup "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Sc() {
#_!_POSIX_#   zypper clean "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Scc() {
#_!_POSIX_#   zypper clean "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Sccc() {
#_!_POSIX_#   # Not way to do this in zypper
#_!_POSIX_#   _not_implemented
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Si() {
#_!_POSIX_#   zypper info --requires "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_Sii() {
#_!_POSIX_#   # Ugly and slow, but does the trick
#_!_POSIX_#   local packages=
#_!_POSIX_# 
#_!_POSIX_#   packages="$(zypper pa -R | cut -d \| -f 3 | tr -s '\n' ' ')"
#_!_POSIX_#   for package in $packages; do
#_!_POSIX_#     zypper info --requires "$package" \
#_!_POSIX_#     | grep -q "$@" && echo "$package"
#_!_POSIX_#   done
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_S() {
#_!_POSIX_#   # shellcheck disable=SC2086
#_!_POSIX_#   zypper install $_TOPT "$@"
#_!_POSIX_# }
#_!_POSIX_# 
#_!_POSIX_# zypper_U() {
#_!_POSIX_#   zypper install "$@"
#_!_POSIX_# }
_validate_operation() {
  case "$1" in
  "apk_Q") ;;
  "apk_Qi") ;;
  "apk_Ql") ;;
  "apk_Qo") ;;
  "apk_Qs") ;;
  "apk_Qu") ;;
  "apk_R") ;;
  "apk_Rn") ;;
  "apk_Rns") ;;
  "apk_Rs") ;;
  "apk_S") ;;
  "apk_Sc") ;;
  "apk_Scc") ;;
  "apk_Sccc") ;;
  "apk_Si") ;;
  "apk_Sii") ;;
  "apk_Sl") ;;
  "apk_Ss") ;;
  "apk_Su") ;;
  "apk_Suy") ;;
  "apk_Sy") ;;
  "apk_U") ;;
  "cave_Q") ;;
  "cave_Qi") ;;
  "cave_Ql") ;;
  "cave_Qo") ;;
  "cave_Qp") ;;
  "cave_Qu") ;;
  "cave_Qs") ;;
  "cave_Rs") ;;
  "cave_Rn") ;;
  "cave_Rns") ;;
  "cave_R") ;;
  "cave_Si") ;;
  "cave_Suy") ;;
  "cave_Su") ;;
  "cave_Sy") ;;
  "cave_Ss") ;;
  "cave_Sc") ;;
  "cave_Scc") ;;
  "cave_Sccc") ;;
  "cave_S") ;;
  "cave_U") ;;
  "conda_Q") ;;
  "conda_R") ;;
  "conda_S") ;;
  "conda_Sc") ;;
  "conda_Si") ;;
  "conda_Ss") ;;
  "conda_Suy") ;;
  "dnf_S") ;;
  "dnf_Sc") ;;
  "dnf_Scc") ;;
  "dnf_Sccc") ;;
  "dnf_Si") ;;
  "dnf_Sg") ;;
  "dnf_Sl") ;;
  "dnf_Ss") ;;
  "dnf_Su") ;;
  "dnf_Suy") ;;
  "dnf_Sy") ;;
  "dnf_Q") ;;
  "dnf_Qc") ;;
  "dnf_Qe") ;;
  "dnf_Qi") ;;
  "dnf_Ql") ;;
  "dnf_Qm") ;;
  "dnf_Qo") ;;
  "dnf_Qp") ;;
  "dnf_Qs") ;;
  "dnf_Qu") ;;
  "dnf_R") ;;
  "dnf_U") ;;
  "dpkg_Q") ;;
  "dpkg_Qi") ;;
  "dpkg_Ql") ;;
  "dpkg_Qo") ;;
  "dpkg_Qp") ;;
  "dpkg_Qu") ;;
  "dpkg_Qs") ;;
  "dpkg_Rs") ;;
  "dpkg_Rn") ;;
  "dpkg_Rns") ;;
  "dpkg_R") ;;
  "dpkg_Si") ;;
  "dpkg_Suy") ;;
  "dpkg_Su") ;;
  "dpkg_Sy") ;;
  "dpkg_Ss") ;;
  "dpkg_Sc") ;;
  "dpkg_Scc") ;;
  "dpkg_S") ;;
  "dpkg_U") ;;
  "dpkg_Sii") ;;
  "dpkg_Sccc") ;;
  "homebrew_Qi") ;;
  "homebrew_Ql") ;;
  "homebrew_Qo") ;;
  "homebrew_Qc") ;;
  "homebrew_Qu") ;;
  "homebrew_Qs") ;;
  "homebrew_Q") ;;
  "homebrew_Rs") ;;
  "homebrew_R") ;;
  "homebrew_Si") ;;
  "homebrew_Suy") ;;
  "homebrew_Su") ;;
  "homebrew_Sy") ;;
  "homebrew_Ss") ;;
  "homebrew_Sc") ;;
  "homebrew_Scc") ;;
  "homebrew_Sccc") ;;
  "homebrew_S") ;;
  "macports_Ql") ;;
  "macports_Qo") ;;
  "macports_Qc") ;;
  "macports_Qu") ;;
  "macports_Rs") ;;
  "macports_R") ;;
  "macports_Si") ;;
  "macports_Suy") ;;
  "macports_Su") ;;
  "macports_Sy") ;;
  "macports_Ss") ;;
  "macports_Sc") ;;
  "macports_Scc") ;;
  "macports_S") ;;
  "opkg_Sy") ;;
  "opkg_Q") ;;
  "opkg_Qi") ;;
  "opkg_Ql") ;;
  "opkg_Qo") ;;
  "opkg_Qs") ;;
  "opkg_Qu") ;;
  "opkg_R") ;;
  "opkg_S") ;;
  "opkg_Si") ;;
  "opkg_Sii") ;;
  "opkg_Ss") ;;
  "opkg_Su") ;;
  "opkg_U") ;;
  "pkgng_Qi") ;;
  "pkgng_Ql") ;;
  "pkgng_Qo") ;;
  "pkgng_Qp") ;;
  "pkgng_Qu") ;;
  "pkgng_Q") ;;
  "pkgng_Rs") ;;
  "pkgng_R") ;;
  "pkgng_Si") ;;
  "pkgng_Suy") ;;
  "pkgng_Su") ;;
  "pkgng_Sy") ;;
  "pkgng_Ss") ;;
  "pkgng_Sc") ;;
  "pkgng_Scc") ;;
  "pkgng_S") ;;
  "pkg_tools_Qi") ;;
  "pkg_tools_Ql") ;;
  "pkg_tools_Qo") ;;
  "pkg_tools_Qp") ;;
  "pkg_tools_Qu") ;;
  "pkg_tools_Q") ;;
  "pkg_tools_Rs") ;;
  "pkg_tools_Rn") ;;
  "pkg_tools_Rns") ;;
  "pkg_tools_R") ;;
  "pkg_tools_Si") ;;
  "pkg_tools_Sl") ;;
  "pkg_tools_Suy") ;;
  "pkg_tools_Su") ;;
  "pkg_tools_Sy") ;;
  "pkg_tools_Ss") ;;
  "pkg_tools_Sc") ;;
  "pkg_tools_Scc") ;;
  "pkg_tools_S") ;;
  "portage_Qi") ;;
  "portage_Ql") ;;
  "portage_Qo") ;;
  "portage_Qc") ;;
  "portage_Qu") ;;
  "portage_Q") ;;
  "portage_Rs") ;;
  "portage_R") ;;
  "portage_Si") ;;
  "portage_Suy") ;;
  "portage_Su") ;;
  "portage_Sy") ;;
  "portage_Ss") ;;
  "portage_Sc") ;;
  "portage_Scc") ;;
  "portage_Sccc") ;;
  "portage_S") ;;
  "sun_tools_Qi") ;;
  "sun_tools_Ql") ;;
  "sun_tools_Qo") ;;
  "sun_tools_Qs") ;;
  "sun_tools_Q") ;;
  "sun_tools_R") ;;
  "sun_tools_U") ;;
  "swupd_Qk") ;;
  "swupd_Qo") ;;
  "swupd_Qs") ;;
  "swupd_R") ;;
  "swupd_Suy") ;;
  "swupd_Su") ;;
  "swupd_Sy") ;;
  "swupd_Ss") ;;
  "swupd_S") ;;
  "tazpkg_Q") ;;
  "tazpkg_Qi") ;;
  "tazpkg_Ql") ;;
  "tazpkg_Sy") ;;
  "tazpkg_Su") ;;
  "tazpkg_Suy") ;;
  "tazpkg_S") ;;
  "tazpkg_R") ;;
  "tazpkg_Sc") ;;
  "tazpkg_Scc") ;;
  "tazpkg_Ss") ;;
  "tazpkg_Qo") ;;
  "tazpkg_U") ;;
  "tlmgr_Qi") ;;
  "tlmgr_Qk") ;;
  "tlmgr_Ql") ;;
  "tlmgr_R") ;;
  "tlmgr_S") ;;
  "tlmgr_Si") ;;
  "tlmgr_Sl") ;;
  "tlmgr_Ss") ;;
  "tlmgr_Suy") ;;
  "tlmgr_U") ;;
  "yum_Q") ;;
  "yum_Qi") ;;
  "yum_Qs") ;;
  "yum_Ql") ;;
  "yum_Qo") ;;
  "yum_Qp") ;;
  "yum_Qc") ;;
  "yum_Qu") ;;
  "yum_Qm") ;;
  "yum_Rs") ;;
  "yum_R") ;;
  "yum_Si") ;;
  "yum_Suy") ;;
  "yum_Su") ;;
  "yum_Sy") ;;
  "yum_Ss") ;;
  "yum_Sc") ;;
  "yum_Scc") ;;
  "yum_Sccc") ;;
  "yum_S") ;;
  "yum_U") ;;
  "yum_Sii") ;;
  "zypper_Qc") ;;
  "zypper_Qi") ;;
  "zypper_Ql") ;;
  "zypper_Qu") ;;
  "zypper_Qm") ;;
  "zypper_Qo") ;;
  "zypper_Qp") ;;
  "zypper_Qs") ;;
  "zypper_Q") ;;
  "zypper_Rs") ;;
  "zypper_R") ;;
  "zypper_Rn") ;;
  "zypper_Rs") ;;
  "zypper_Rns") ;;
  "zypper_Suy") ;;
  "zypper_Sy") ;;
  "zypper_Sl") ;;
  "zypper_Ss") ;;
  "zypper_Su") ;;
  "zypper_Sc") ;;
  "zypper_Scc") ;;
  "zypper_Sccc") ;;
  "zypper_Si") ;;
  "zypper_Sii") ;;
  "zypper_S") ;;
  "zypper_U") ;;
  *) return 1 ;;
  esac
}



set -u

unset GREP_OPTIONS

: "${PACAPT_DEBUG=}"  # Show what will be going
: "${GREP:=grep}"     # Need to update in, e.g, _sun_tools_init
: "${AWK:=awk}"       # Need to update in, e.g, _sun_tools_init

local_requirements="$GREP $AWK"
if ! _sun_tools_init; then
  local_requirements="${local_requirements} sed"
fi

for cmd in $local_requirements; do
  if ! command -v "$cmd" >/dev/null; then
    _die "pacapt requires '$cmd' but the tool is not found."
  fi
done

export PACAPT_DEBUG GREP AWK

if [ -z "${__PACAPT_FORKED__:-}" ]; then
  if command -v bash >/dev/null; then
    _debug "Switching to Bash shell"
    export __PACAPT_FORKED__="yes"
    readonly __PACAPT_FORKED__

    exec bash "$0" "${@}"
  fi
else
  # Hey, this is very awesome strick to avoid syntax issue.
  # Note: in `bocker` (github.com/icy/bocker/) we use `base64`.
  eval 'source /dev/stdin < <("$GREP" '^#_!_POSIX_#' "$0" | sed -e 's/^#_!_POSIX_#//')' \
  || _die "$0: Unable to load non-POSIX definitions".
fi


_POPT=""    # primary operation
_SOPT=""    # secondary operation
_TOPT=""    # options for operations
_EOPT=""    # extra options (directly given to package manager)
            # these options will be translated by (_translate_all) method.
_PACMAN=""  # name of the package manager

_PACMAN_detect \
|| _die "'pacapt' doesn't support your package manager."

if [ -z "${__PACAPT_FORKED__:-}" ]; then
  case "$_PACMAN" in
  "apk")  ;;
  "opkg")  ;;
  "sun_tools" ) ;;
  *)
    _die "pacapt($_PACMAN) library is not ready for pure-POSIX features."
  esac
fi

if [ -z "$PACAPT_DEBUG" ]; then
  [ "$_PACMAN" != "pacman" ] \
  || exec "/usr/bin/pacman" "$@"
elif [ "$PACAPT_DEBUG" != "auto" ]; then
  _PACMAN="$PACAPT_DEBUG"
fi

case "${1:-}" in
"update")     shift; set -- -Sy   "$@" ;;
"upgrade")    shift; set -- -Su   "$@" ;;
"install")    shift; set -- -S    "$@" ;;
"search")     shift; set -- -Ss   "$@" ;;
"remove")     shift; set -- -R    "$@" ;;
"autoremove") shift; set -- -Rs   "$@" ;;
"clean")      shift; set -- -Scc  "$@" ;;
esac

while :; do
  _args="${1-}"

  [ "$(printf "%.1s" "$_args")" = "-" ] || break

  case "${_args}" in
  "--help")
    _help
    exit 0
    ;;

  "--noconfirm")
    shift
    _EOPT="$_EOPT:noconfirm:"
    continue
    ;;

  "-"|"--")
    shift
    break
    ;;
  esac

  i=1
  while [ "$i" -lt "${#_args}" ]; do
    i=$(( i + 1))
    _opt="$(_string_nth "$i" "$_args")"

    case "$_opt" in
    h)
      _help
      exit 0
      ;;
    V)
      _print_pacapt_version;
      exit 0
      ;;
    P)
      _print_supported_operations "$_PACMAN"
      exit 0
      ;;

    Q|S|R|U)
      if [ -n "$_POPT" ] && [ "$_POPT" != "$_opt" ]; then
        _error "Only one operation may be used at a time"
        exit 1
      fi
      _POPT="$_opt"
      ;;

    # Comment 2015 May 26th: This part deals with the 2nd option.
    # Most of the time, there is only one 2nd option. But some
    # operation may need extra and/or duplicate (e.g, Sy <> Syy).
    #
    # See also
    #
    # * https://github.com/icy/pacapt/issues/13
    #
    #   This implementation works, but with a bug. #Rsn works
    #   but #Rns is translated to #Rn (incorrectly.)
    #   Thanks Huy-Ngo for this nice catch.
    #
    # FIXME: Please check pacman(8) to see if they are really 2nd operation
    #
    e|g|i|l|m|n|o|p|s)
      if [ -z "$_SOPT" ]; then
        _SOPT="$_opt"
        continue
      fi

      # Understand it:
      # If there is already an option recorded, the incoming option
      # will come and compare itself with known one.
      # We have a table
      #
      #     known one vs. incoming ? | result
      #                <             | one-new
      #                =             | one-one
      #                >             | new-one
      #
      # Let's say, after this step, the 3rd option comes (named X),
      # and the current result is "a-b". We have a table
      #
      #    a(b) vs. X  | result
      #         <      | aX (b dropped)
      #         =      | aa (b dropped)
      #         >      | Xa (b dropped)
      #
      # In any case, the first one matters.
      #
      f_SOPT="$(printf "%.1s" "$_SOPT")"
      if _string_less_than "$f_SOPT" "$_opt"; then
        _SOPT="${f_SOPT}$_opt"
      elif [ "${f_SOPT}" = "$_opt" ]; then
        _SOPT="$_opt$_opt"
      else
        _SOPT="$_opt${f_SOPT}"
      fi

      ;;

    q)
      _TOPT="$_opt" ;; # Thanks to James Pearson

    u)
      f_SOPT="$(printf "%.1s" "$_SOPT")"
      if [ "$f_SOPT" = "y" ]; then
        _SOPT="uy"
      else
        _SOPT="u"
      fi
      ;;

    y)
      f_SOPT="$(printf "%.1s" "$_SOPT")"
      if [ "${f_SOPT}" = "y" ]; then
        _SOPT="uy"
      else
        _SOPT="y"
      fi
      ;;

    c)
      if [ "$(printf "%.2s" "$_SOPT")" = "cc" ]; then
        _SOPT="ccc"
      elif [ "$(printf "%.1s" "$_SOPT")" = "c" ]; then
        _SOPT="cc"
      else
        _SOPT="$_opt"
      fi
      ;;

    w|v)
      _EOPT="$_EOPT:$_opt:"
      ;;

    *)
      # FIXME: If option is unknown, we will break the loop
      # FIXME: and this option will be used by the native program.
      # FIXME: break 2
      _die "$0: Unknown option '$_opt'."
      ;;
    esac
  done

  shift

  # If the primary option and the secondary are known
  # we would break the argument detection, but for sure we will look
  # forward to see there is anything interesting...
  if [ -n "$_POPT" ] && [ -n "$_SOPT" ]; then
    case "${1:-}" in
    "-w"|"--noconfirm") ;;
    *) break;;
    esac

  # Don't have anything from the **first** argument. Something wrong.
  # FIXME: This means that user must enter at least primary action
  # FIXME: or secondary action in the very first part...
  elif [ -z "${_POPT}${_SOPT}${_TOPT}" ]; then
    break
  fi
done

[ -n "$_POPT" ] \
|| _die "Usage: $0 <options>   # -h for help, -P list supported functions"

_validate_operation "${_PACMAN}_${_POPT}${_SOPT}" \
|| {
  _not_implemented
  exit 1
}

_translate_all || exit

if [ -n "$*" ]; then
  case "${_POPT}${_SOPT}" in
  "Su"|"Sy"|"Suy")
    echo 1>&2 "WARNING ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
    echo 1>&2 "  The -Sy/u options refresh and/or upgrade all packages."
    echo 1>&2 "  To install packages as well, use separate commands:"
    echo 1>&2
    echo 1>&2 "    $0 -S$_SOPT; $0 -S ${*}"
    echo 1>&2 "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  esac
fi

if [ -n "$PACAPT_DEBUG" ]; then
  echo "pacapt: $_PACMAN, p=$_POPT, s=$_SOPT, t=$_TOPT, e=$_EOPT"
  echo "pacapt: execute '${_PACMAN}_${_POPT}${_SOPT} $_EOPT ${*}'"
  if command -v declare >/dev/null; then
    # shellcheck disable=SC3044
    declare -f "${_PACMAN}_${_POPT}${_SOPT}"
  else
    _error "Attempted to print the defintion of the method '${_PACMAN}_${_POPT}${_SOPT}'."
    _error "However, unable to find method ('declare'). Maybe your shell is purely POSIX?"
  fi
else
  "_${_PACMAN}_init" || exit
  # shellcheck disable=SC2086
  "${_PACMAN}_${_POPT}${_SOPT}" $_EOPT "$@"
fi
